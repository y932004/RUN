<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
<title>Runner Rigid - 倒數校正 & 距離自適應版</title>
<style>
  html,body{margin:0;overflow:hidden;background:#000;font-family:"Microsoft JhengHei", sans-serif;}
  
  /* 相機容器 */
  #camera-container {
    position:absolute; top:10px; right:10px;
    width:160px; height:120px;
    z-index:5;
    transform: scaleX(-1);
    border: 2px solid #00ffff;
    border-radius: 8px;
    overflow: hidden;
    background: #000;
  }
  
  #debugVideo, #output_canvas {
    position: absolute; top: 0; left: 0;
    width: 100%; height: 100%;
  }
  #debugVideo { object-fit: cover; opacity: 0.6; }
  
  /* HUD 介面 */
  #hud{
    position:absolute;top:10px;left:10px;color:#fff;
    background:rgba(0,0,0,0.6);padding:10px;border-radius:8px;z-index:3;
    min-width: 200px;
  }
  #hud span{display:block;margin:4px 0;font-size: 16px;}
  #hud .status-icon { display:inline-block; width:10px; height:10px; border-radius:50%; margin-right:5px; background:#555;}
  #hud .status-active { background: #0f0; box-shadow: 0 0 5px #0f0;}

  /* 校正按鈕樣式 */
  #calibrate-btn {
    background: #ff9900; color: #000; font-weight: bold;
    border: none; padding: 8px 10px; border-radius: 4px;
    cursor: pointer; margin-top: 5px; width: 100%; font-size: 16px;
    transition: background 0.3s;
  }
  #calibrate-btn:disabled { background: #555; color: #aaa; cursor: wait; }

  #popup{
    position:fixed;inset:0;background:rgba(0,0,0,0.85);display:none;
    align-items:center;justify-content:center;flex-direction:column;
    color:#fff;z-index:10;backdrop-filter: blur(5px);
  }
  #popup h2{font-size: 32px; margin-bottom:10px; color: #00bfff;}
  #popup button{
    margin-top:20px;padding:10px 30px;font-size:20px;
    border:none;border-radius:50px;background:linear-gradient(45deg, #00bfff, #0088ff);
    color:#fff;cursor:pointer;
  }
</style>
</head>
<body>
  
<div id="hud">
  <span id="score">分數：0</span>
  <span id="timer">時間：60</span>
  
  <button id="calibrate-btn" onclick="startCalibrationCountdown()">⏱️ 5秒後校正 (請後退)</button>
  <div style="font-size:12px; color:#aaa; margin-bottom:5px;">
    基準高: <span id="cali-val">--</span> | 身高比: <span id="body-scale">--</span>
  </div>

  <div style="margin-top:10px; border-top:1px solid #555; padding-top:5px;">
    <span><i id="runInd" class="status-icon"></i>跑步 (Run)</span>
    <span><i id="jumpInd" class="status-icon"></i>跳躍 (Jump)</span>
    <span><i id="crouchInd" class="status-icon"></i>蹲下 (Crouch)</span>
  </div>
</div>

<div id="popup">
  <h2>GAME OVER</h2>
  <p id="finalStats" style="font-size:24px;"></p>
  <button onclick="location.reload()">再跑一次</button>
</div>

<div id="camera-container">
    <video id="debugVideo" playsinline muted></video>
    <canvas id="output_canvas"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>

<script type="module">
import { onAuth, addCoins } from './firebase-utils.js';
// ==========================================
// 1. 遊戲設定
// ==========================================

// 擴充背景樣式設定

const Backgrounds = {
    'cyberpunk': { color: 0x110022, grid: 0xff00ff }, // 預設
    'dark':      { color: 0x222222, grid: 0x444444 },
    // 新增對應 Store 的場景
    'forest':    { color: 0x2d5a27, grid: 0x8fbc8f }, // 綠色系
    'ice':       { color: 0xcfefff, grid: 0x00bfff }, // 冰藍色系
    'desert':    { color: 0xe6ccb2, grid: 0xd2691e }  // 沙漠黃系
};

const Skins = {
    'default': { name: "綠色像素人", colors: { head: 0x00ff00, body: 0x00aa00, limb: 0x00ff00 } },
    'robot':   { name: "鋼鐵機甲",   colors: { head: 0xcccccc, body: 0xff0000, limb: 0x888888 } },
    // 新增商店角色配色
    'apple':   { name: "蘋果17",     colors: { head: 0x32cd32, body: 0xff0000, limb: 0x8b0000 } }, // 紅身綠葉
    'banana':  { name: "香蕉",       colors: { head: 0xfffacd, body: 0xffd700, limb: 0xcccc00 } }, // 黃色系
    'tomato':  { name: "番茄",       colors: { head: 0x228b22, body: 0xff6347, limb: 0xcd5c5c } }  // 番茄紅
};

// 從 localStorage 讀取玩家選擇的場景，如果沒有就用預設值 'cyberpunk'
const savedScene = localStorage.getItem('equippedScene');
const savedSkin  = localStorage.getItem('equippedSkin');

const GameConfig = {
    baseSpeed: 0.15,
    isGameRunning: true,
    // 檢查讀取到的 skin 是否存在於 Skins 列表中，否則用 default
    currentSkin: (savedSkin && Skins[savedSkin]) ? savedSkin : 'default',
    currentBg: (savedScene && Backgrounds[savedScene]) ? savedScene : 'cyberpunk'
};



// ==========================================
// 2. Three.js 場景
// ==========================================
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(Backgrounds[GameConfig.currentBg].color, 0.03); 

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
camera.position.set(0, 3, 6);
camera.lookAt(0, 1, 0);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(Backgrounds[GameConfig.currentBg].color);
document.body.appendChild(renderer.domElement);

const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(5, 10, 7);
scene.add(dirLight);

const gridHelper = new THREE.GridHelper(100, 100, Backgrounds[GameConfig.currentBg].grid, 0x222222);
scene.add(gridHelper);

// ==========================================
// 3. 角色與障礙物
// ==========================================
const characterGroup = new THREE.Group();
scene.add(characterGroup);
let bodyMeshes = {};

function loadCharacterSkin(skinId) {
    while(characterGroup.children.length > 0) characterGroup.remove(characterGroup.children[0]);
    bodyMeshes = {};
    const data = Skins[skinId] || Skins['default'];
    const matHead = new THREE.MeshPhongMaterial({color: data.colors.head});
    const matBody = new THREE.MeshPhongMaterial({color: data.colors.body});
    const matLimb = new THREE.MeshPhongMaterial({color: data.colors.limb});

    const createBox = (w, h, d, mat, x, y, z, name) => {
        const geo = new THREE.BoxGeometry(w, h, d);
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(x, y, z);
        characterGroup.add(mesh);
        bodyMeshes[name] = mesh;
        return mesh;
    };
    createBox(0.5, 0.7, 0.3, matBody, 0, 1.15, 0, 'torso');
    createBox(0.4, 0.4, 0.4, matHead, 0, 1.75, 0, 'head');
    const createLimb = (x, y, name, isArm) => {
        const g = new THREE.Group();
        g.position.set(x, y, 0);
        const m = new THREE.Mesh(new THREE.BoxGeometry(isArm?0.15:0.2, isArm?0.6:0.8, isArm?0.15:0.2), matLimb);
        m.position.y = isArm?-0.3:-0.4;
        g.add(m);
        characterGroup.add(g);
        bodyMeshes[name] = g;
    };
    createLimb(-0.4, 1.4, 'leftArmGroup', true);
    createLimb(0.4, 1.4, 'rightArmGroup', true);
    createLimb(-0.2, 0.8, 'leftLegGroup', false);
    createLimb(0.2, 0.8, 'rightLegGroup', false);
}
loadCharacterSkin(GameConfig.currentSkin);

const obstacles = [];
const OBS_TYPE_LOW = 1, OBS_TYPE_HIGH = 2;
function spawnObstacle() {
    const type = Math.random() > 0.5 ? OBS_TYPE_LOW : OBS_TYPE_HIGH;
    const geometry = new THREE.BoxGeometry(4, 0.5, 0.5);
    const material = new THREE.MeshPhongMaterial({color: type===OBS_TYPE_LOW?0xff3333:0xffff33});
    const obs = new THREE.Mesh(geometry, material);
    obs.position.set(0, type===OBS_TYPE_LOW?0.25:1.6, -30);
    obs.userData = { type: type, active: true };
    scene.add(obs);
    obstacles.push(obs);
}

// ==========================================
// 4. 動作偵測核心 (倒數校正 + 距離自適應)
// ==========================================
let playerState = { isRunning: false, isJumping: false, isCrouching: false, runEnergy: 0 };
let calibrationData = { baseHipY: 0.5, bodyScale: 0.3, isCalibrated: false }; // bodyScale = 身體在畫面中的大小
let currentPose = null;

// --- 新增：倒數計時校正 ---
function startCalibrationCountdown() {
    const btn = document.getElementById('calibrate-btn');
    if(btn.disabled) return;
    
    let timeLeft = 5;
    btn.disabled = true;
    
    // 立即更新 UI
    btn.style.background = "#ff4444"; // 紅色提醒
    btn.textContent = `⏳ 請後退到定位... ${timeLeft}`;

    const interval = setInterval(() => {
        timeLeft--;
        if (timeLeft > 0) {
            btn.textContent = `⏳ 請後退到定位... ${timeLeft}`;
        } else {
            clearInterval(interval);
            performCalibration();
        }
    }, 1000);
}

function performCalibration() {
    const btn = document.getElementById('calibrate-btn');
    if(!currentPose) {
        alert("未偵測到全身，請調整位置！");
        btn.disabled = false;
        btn.style.background = "#ff9900";
        btn.textContent = "⏱️ 5秒後校正 (重試)";
        return;
    }

    const lm = currentPose;
    const hipY = (lm[23].y + lm[24].y) / 2;
    const shoulderY = (lm[11].y + lm[12].y) / 2;

    // 計算身體在畫面中的「高度比例」 (肩膀到臀部的距離)
    // 站得遠，這個值會很小(例如0.1)；站得近，這個值會很大(例如0.4)
    let scale = Math.abs(hipY - shoulderY);
    if(scale < 0.05) scale = 0.05; // 避免極端值

    calibrationData.baseHipY = hipY;
    calibrationData.bodyScale = scale;
    calibrationData.isCalibrated = true;
    
    // 更新 UI
    document.getElementById('cali-val').textContent = hipY.toFixed(2);
    document.getElementById('body-scale').textContent = scale.toFixed(3);
    
    btn.style.background = "#00cc00"; // 綠色成功
    btn.textContent = "✅ 校正成功！";
    
    setTimeout(() => {
        btn.disabled = false;
        btn.style.background = "#ff9900";
        btn.textContent = "⏱️ 重新校正 (5秒)";
    }, 2000);
}

const videoElement = document.getElementById('debugVideo');
const canvasElement = document.getElementById('output_canvas');
const canvasCtx = canvasElement.getContext('2d');

const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
pose.onResults(onPoseResults);

const cameraUtils = new Camera(videoElement, {
    onFrame: async () => { await pose.send({image: videoElement}); },
    width: 320, height: 240
});
cameraUtils.start();

function onPoseResults(results) {
    // 繪製骨架
    canvasElement.width = videoElement.videoWidth;
    canvasElement.height = videoElement.videoHeight;
    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
    if(results.poseLandmarks){
        const connections = window.Pose ? Pose.POSE_CONNECTIONS : (window.POSE_CONNECTIONS || []);
        drawConnectors(canvasCtx, results.poseLandmarks, connections, {color: '#00FF00', lineWidth: 4});
        drawLandmarks(canvasCtx, results.poseLandmarks, {color: '#FF0000', lineWidth: 2, radius: 4});
    }
    canvasCtx.restore();

    if (!results.poseLandmarks) return;
    const lm = results.poseLandmarks;
    currentPose = lm;

    const leftHip = lm[23], rightHip = lm[24];
    const leftKnee = lm[25], rightKnee = lm[26];
    const leftShoulder = lm[11], rightShoulder = lm[12];

    // 1. 計算目前的數據
    const currentHipY = (leftHip.y + rightHip.y) / 2;
    const currentScale = calibrationData.isCalibrated ? calibrationData.bodyScale : Math.abs(currentHipY - (leftShoulder.y + rightShoulder.y)/2);

    // 2. 自動更新基準 (如果沒校正)
    if (!calibrationData.isCalibrated) {
        calibrationData.baseHipY = calibrationData.baseHipY * 0.95 + currentHipY * 0.05;
    }

    // 3. 動作判定 (全部依賴 bodyScale 進行正規化)
    // 這樣不管你站多遠，判定標準都是 "身高的 X 倍"
    const diff = currentHipY - calibrationData.baseHipY; // 正數=蹲, 負數=跳
    
    // 跳躍閾值：身高的 25%
    const JUMP_THRESH = - (currentScale * 0.25); 
    // 蹲下閾值：身高的 30%
    const CROUCH_THRESH = (currentScale * 0.30);

    if (diff < JUMP_THRESH) {
        playerState.isJumping = true;
        playerState.isCrouching = false;
    } else if (diff > CROUCH_THRESH) {
        playerState.isCrouching = true;
        playerState.isJumping = false;
    } else {
        playerState.isJumping = false;
        playerState.isCrouching = false;
    }

    // 4. 跑步判定 (改良版)
    // 使用膝蓋的高低差 (Knee Delta) 來判斷，比腳踝更穩定
    const kneeDiff = Math.abs(leftKnee.y - rightKnee.y);
    
    // 跑步閾值：只要膝蓋交替高度超過身高的 10% 就算跑
    const RUN_THRESH = currentScale * 0.10;

    // 必須不在跳躍/蹲下狀態，且有足夠的膝蓋擺動
    if (kneeDiff > RUN_THRESH && !playerState.isJumping && !playerState.isCrouching) {
        // 增加能量比較快，停止比較慢
        playerState.runEnergy = Math.min(playerState.runEnergy + 5, 25);
    } else {
        playerState.runEnergy = Math.max(playerState.runEnergy - 1, 0);
    }
    playerState.isRunning = playerState.runEnergy > 8;

    updateHUD();
}

function updateHUD() {
    document.getElementById('runInd').className = 'status-icon ' + (playerState.isRunning ? 'status-active' : '');
    document.getElementById('jumpInd').className = 'status-icon ' + (playerState.isJumping ? 'status-active' : '');
    document.getElementById('crouchInd').className = 'status-icon ' + (playerState.isCrouching ? 'status-active' : '');
}

// ==========================================
// 5. 遊戲迴圈
// ==========================================
let score = 0;
let time = 60;
let clock = new THREE.Clock();
let runTime = 0;

const timerInterval = setInterval(() => {
    if(!GameConfig.isGameRunning) return;
    time--;
    document.getElementById('timer').textContent = "時間：" + time;
    if(time <= 0) endGame();
}, 1000);

function endGame() {
    GameConfig.isGameRunning = false;
    document.getElementById('popup').style.display = "flex";
        // 計算獎勵規則：每 5 分給 5 金幣（提高獎勵比例），至少 10 金幣
        const reward = Math.max(10, Math.floor(score / 5) * 5);
        document.getElementById('finalStats').textContent = `最終分數：${score}，獲得金幣：${reward}`;
        // 嘗試把金幣發放到使用者帳戶（如果有登入）
        try {
            onAuth(async (user) => {
                if (!user) return; // 未登入則跳過
                try {
                    const newBal = await addCoins(user.uid, reward, `ReflexRidge reward: score ${score}`);
                    console.log('reward applied, new balance:', newBal);
                } catch (e) {
                    console.error('addCoins error', e);
                }
            });
        } catch (e) {
            console.error('auth hook failed', e);
        }
    clearInterval(timerInterval);
}

function checkCollisions() {
    obstacles.forEach(obs => {
        if (!obs.userData.active) return;
        const zDist = obs.position.z - characterGroup.position.z;
        if (zDist > -1 && zDist < 1) {
            let hit = false;
            if (obs.userData.type === OBS_TYPE_LOW && !playerState.isJumping) hit = true;
            if (obs.userData.type === OBS_TYPE_HIGH && !playerState.isCrouching) hit = true;

            if (hit) {
                score = Math.max(0, score - 2);
                obs.material.color.set(0x555555);
                obs.userData.active = false;
                camera.position.x = (Math.random()-0.5)*0.5;
                setTimeout(()=>camera.position.x=0, 100);
            } else {
                if(!obs.userData.passed) { score += 20; obs.userData.passed = true; }
            }
            document.getElementById('score').textContent = "分數：" + score;
        }
    });
}

function animate() {
    requestAnimationFrame(animate);
    if (!GameConfig.isGameRunning) return;

    const delta = clock.getDelta();
    runTime += delta * 10;
    
    let currentMoveSpeed = 0;
    if (playerState.isRunning || playerState.isJumping) {
        currentMoveSpeed = GameConfig.baseSpeed + (playerState.isRunning ? 0.2 : 0);
    }

    gridHelper.position.z = (gridHelper.position.z + currentMoveSpeed) % 10;

    for (let i = obstacles.length - 1; i >= 0; i--) {
        let obs = obstacles[i];
        obs.position.z += currentMoveSpeed;
        if (obs.position.z > 5) { scene.remove(obs); obstacles.splice(i, 1); }
    }

    if (currentMoveSpeed > 0 && Math.random() < 0.02 && obstacles.length < 3) {
        if (obstacles.length === 0 || obstacles[obstacles.length-1].position.z > -15) spawnObstacle();
    }

    characterGroup.position.y = 0;
    bodyMeshes.torso.rotation.x = 0;
    
    if (playerState.isJumping) {
        characterGroup.position.y = 1.5;
        bodyMeshes.leftLegGroup.rotation.x = -0.5; bodyMeshes.rightLegGroup.rotation.x = -0.8;
        bodyMeshes.leftArmGroup.rotation.x = -2.5; bodyMeshes.rightArmGroup.rotation.x = -2.5;
    } else if (playerState.isCrouching) {
        characterGroup.position.y = -0.5;
        bodyMeshes.torso.rotation.x = 0.5;
        bodyMeshes.leftLegGroup.rotation.x = -1.5; bodyMeshes.rightLegGroup.rotation.x = -1.5;
        bodyMeshes.leftArmGroup.rotation.x = -0.5; bodyMeshes.rightArmGroup.rotation.x = -0.5;
    } else if (playerState.isRunning) {
        const legAmp = 0.8, armAmp = 0.8;
        bodyMeshes.leftLegGroup.rotation.x = Math.sin(runTime) * legAmp;
        bodyMeshes.rightLegGroup.rotation.x = Math.sin(runTime + Math.PI) * legAmp;
        bodyMeshes.leftArmGroup.rotation.x = Math.sin(runTime + Math.PI) * armAmp;
        bodyMeshes.rightArmGroup.rotation.x = Math.sin(runTime) * armAmp;
        characterGroup.position.y = Math.abs(Math.sin(runTime * 2)) * 0.1;
    } else {
        bodyMeshes.leftLegGroup.rotation.x = 0; bodyMeshes.rightLegGroup.rotation.x = 0;
        bodyMeshes.leftArmGroup.rotation.x = Math.sin(Date.now()*0.002)*0.05;
        bodyMeshes.rightArmGroup.rotation.x = Math.sin(Date.now()*0.002 + Math.PI)*0.05;
    }

    checkCollisions();
    renderer.render(scene, camera);
}
animate();
window.addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>