<!DOCTYPE html> 
<html lang="zh-TW">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Aqua Fix VR Mode – 完美生態平衡版</title>
<style>
  body{margin:0;overflow:hidden;background:#000;font-family:"Microsoft JhengHei",sans-serif;color:#fff;}
  #score,#timer{position:absolute;top:10px;background:rgba(0,0,0,.5);padding:6px 12px;border-radius:8px;font-size:20px;z-index:3}
  #score{left:10px}#timer{right:10px}
  video,canvas{position:absolute;top:0;left:0;width:100%;height:auto}
  #assets { display: none; }
</style>
</head>
<body>
<div id="score">分數：0</div>
<div id="timer">剩餘時間：60秒</div>
<video id="video" autoplay playsinline muted style="display:none"></video>
<canvas id="gameCanvas"></canvas>

<div id="assets">
  <img id="fish1" src="./imageSea/cutefish.png">
  <img id="fish2" src="./imageSea/goldfish.png">
  <img id="fish3" src="./imageSea/jellyfish.png">
  <img id="crab"     src="./imageSea/crab.png">
  <img id="starfish" src="./imageSea/starfish.png">
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>

<script type="module">
import { onAuth, addCoins } from './firebase-utils.js';
const video=document.getElementById("video");
const canvas=document.getElementById("gameCanvas");
const ctx=canvas.getContext("2d");
const scoreEl=document.getElementById("score");
const timerEl=document.getElementById("timer");
canvas.width=640;canvas.height=480;

let score=0,timeLeft=60;
let holes=[], creatures=[], bubbles=[]; 
let handsData=[]; 
const holeRadius=35, dangerTime=4;
let isProcessing = false;

// --- 讀取圖片 ---
const fishImages = [
    document.getElementById("fish1"),
    document.getElementById("fish2"),
    document.getElementById("fish3")
];
const crabImg = document.getElementById("crab");
const starfishImg = document.getElementById("starfish");

function spawnHole(){
  if(holes.length >= 3) return;
  const x=Math.random()*(canvas.width-2*holeRadius)+holeRadius;
  const y=Math.random()*(canvas.height-2*holeRadius)+holeRadius;
  holes.push({x,y,created:Date.now()});
}

// --- 生物生成邏輯 ---
function spawnCreature(){
  const rand = Math.random();
  
  if(rand < 0.1) {
      // --- 生成螃蟹 (新增數量限制) ---
      
      // ★★★ 關鍵修改：先檢查畫面上螃蟹有幾隻 ★★★
      const currentCrabs = creatures.filter(c => c.type === 'crab').length;
      if (currentCrabs >= 2) return; // 如果已經有 2 隻，就不生了！

      creatures.push({
          type: 'crab',
          img: crabImg,
          x: Math.random() * (canvas.width - 100), 
          y: canvas.height - 30, // 貼地位置
          speed: 1.5, 
          scale: 0.8,
          dir: 1,
          targetWidth: 80 
      });
  } else if (rand < 0.25) {
      // --- 生成海星 ---
      creatures.push({
          type: 'starfish',
          img: starfishImg,
          x: -50,
          y: Math.random() * (canvas.height - 150),
          speed: 1.5,
          scale: 0.6,
          angle: 0, 
          rotSpeed: 0.02,
          targetWidth: 60 
      });
  } else {
      // --- 生成游泳的魚/水母 ---
      const fishImg = fishImages[Math.floor(Math.random() * fishImages.length)];
      // 從右邊生成，往左游
      const startX = canvas.width + 100; 
      const swimSpeed = -(2 + Math.random() * 2); 

      creatures.push({
          type: 'fish',
          img: fishImg,
          x: startX,
          y: Math.random() * (canvas.height - 150) + 50,
          speed: swimSpeed,
          scale: 0.9,
          wiggleOffset: Math.random() * 100,
          targetWidth: 75 
      });
  }
}

function addBubble(x,y,strength,color="rgba(200,230,255,0.7)"){
  for(let i=0;i<strength;i++){
    bubbles.push({x:x+Math.random()*20-10,y:y+Math.random()*10-5,
      r:Math.random()*3+2,vy:-1-Math.random()*1.5,life:60,color});
  }
}

function startTimer(){
  const timer=setInterval(()=>{
    timeLeft--;
    timerEl.textContent=`剩餘時間：${timeLeft}秒`;
    if(timeLeft<=0){
        clearInterval(timer);
        // 計算獎勵：每 2 分給 5 金幣，至少 10 金幣
        const reward = Math.max(10, Math.floor(score / 2) * 5);
        try {
          onAuth(async (user) => {
            if (!user) {
              alert(`時間到！你的分數是 ${score}，獲得金幣：${reward}（未登入未記錄）`);
              location.reload();
              return;
            }
            try {
              await addCoins(user.uid, reward, `UnderTheSea reward: score ${score}`);
              // also add sport report
              try { const mod = await import('./firebase-utils.js'); await mod.addSportReport(user.uid, { game: 'UnderTheSea', score, createdAt: new Date() }); } catch(e){console.error('addSportReport failed', e);}
              alert(`時間到！你的分數是 ${score}，獲得金幣：${reward}`);
            } catch (e) {
              console.error('addCoins failed', e);
              alert(`時間到！你的分數是 ${score}，但發放金幣失敗`);
            }
            location.reload();
          });
        } catch (e) {
          console.error('auth hook failed', e);
          alert(`時間到！你的分數是 ${score}`);
          location.reload();
        }
    }
  },1000);
}

function draw(){
  ctx.save();
  ctx.scale(-1,1);
  if(video.readyState === 4){
    ctx.drawImage(video,-canvas.width,0,canvas.width,canvas.height);
  }
  ctx.restore();

  ctx.fillStyle="rgba(0,50,100,0.25)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const now=Date.now();

  //--- 破洞 ---
  holes.forEach((hole,index)=>{
    const age=(now-hole.created)/1000;
    let t=Math.min(age/dangerTime,1);
    const r=Math.floor(0+(255-0)*t);
    const g=Math.floor(150-150*t);
    const b=Math.floor(255-50*t);
    const color=`rgba(${r},${g},${b},0.6)`;
    const flicker=t>0.8?(Math.sin(now/100)*0.5+0.5)*0.4+0.6:1;
    
    ctx.globalAlpha=flicker;
    ctx.beginPath();
    ctx.arc(hole.x,hole.y,holeRadius,0,Math.PI*2);
    ctx.fillStyle=color;
    ctx.fill();
    ctx.strokeStyle="#fff";
    ctx.lineWidth=2;
    ctx.stroke();
    ctx.globalAlpha=1;

    if(t>0.5)addBubble(hole.x,hole.y,Math.ceil(t*2));
    if(t>=1){
      score=Math.max(0,score-1);
      scoreEl.textContent="分數："+score;
      addBubble(hole.x,hole.y,15,"rgba(255,80,80,0.9)");
      holes.splice(index,1);
      spawnCreature();
      spawnHole();
    }
  });

  //--- 氣泡 ---
  bubbles.forEach((b,i)=>{
    ctx.beginPath();
    ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
    ctx.fillStyle=b.color;
    ctx.fill();
    b.y+=b.vy;
    b.life--;
    if(b.life<=0)bubbles.splice(i,1);
  });

  //--- 手部骨架 ---
  if(handsData && handsData.length > 0){
    handsData.forEach(hand=>{
      const mirrored=hand.map(p=>({x:(1-p.x)*canvas.width,y:p.y*canvas.height}));
      drawConnectors(ctx,mirrored,Hands.HAND_CONNECTIONS,{color:"#ffff00",lineWidth:2});
      drawLandmarks(ctx,mirrored,{color:"#ffcc00",radius:4});
    });
  }

  //--- 繪製生物 ---
  creatures.forEach((c, i) => {
      ctx.save();

      // 1. 螃蟹邏輯
      if (c.type === 'crab') {
          c.x += c.speed * c.dir;
          if(c.x > canvas.width - 50 || c.x < 50) {
              c.dir *= -1; 
          }
          ctx.translate(c.x, c.y);
          let walkWobble = Math.sin(now / 100) * 0.1;
          ctx.rotate(walkWobble);

      // 2. 海星邏輯
      } else if (c.type === 'starfish') {
          c.x += c.speed;
          c.angle += c.rotSpeed; 
          ctx.translate(c.x, c.y);
          ctx.rotate(c.angle); 

      // 3. 魚類 (含水母)
      } else {
          c.x += c.speed; 
          let swimY = Math.sin(now / 200 + c.wiggleOffset) * 2; 
          ctx.translate(c.x, c.y + swimY);
          let swimRot = Math.sin(now / 200) * 0.1;
          ctx.rotate(swimRot);
      }

      // 繪製圖片
      if(c.img.complete) {
        const ratio = c.img.height / c.img.width;
        const w = c.targetWidth;
        const h = w * ratio;
        ctx.drawImage(c.img, -w/2, -h/2, w, h);
      }
      
      ctx.restore();

      // 移除超出畫面的生物
      if (c.type !== 'crab' && (c.x < -150 || c.x > canvas.width + 150)) {
          creatures.splice(i, 1);
      }
  });

  //--- 判定 ---
  holes.forEach((hole,index)=>{
    if(handsData){
        handsData.forEach(hand=>{
        let avgX=0,avgY=0;
        hand.forEach(p=>{avgX+=(1-p.x)*canvas.width;avgY+=p.y*canvas.height;});
        avgX/=hand.length;avgY/=hand.length;
        const dx=avgX-hole.x,dy=avgY-hole.y;
        const dist=Math.sqrt(dx*dx+dy*dy);
        if(dist<holeRadius){
            score++;
            scoreEl.textContent="分數："+score;
            addBubble(hole.x,hole.y,10);
            holes.splice(index,1);
            spawnHole();
        }
        });
    }
  });

  requestAnimationFrame(draw);
}

//--- Mediapipe Setup ---
const hands=new Hands({locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});

hands.setOptions({
    maxNumHands: 2,
    modelComplexity: 0, 
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
});

hands.onResults(r=>{
    handsData=r.multiHandLandmarks||[];
});

async function startCamera(){
  try {
    const stream=await navigator.mediaDevices.getUserMedia({video:true});
    video.srcObject=stream;
    await video.play();
  } catch(e) {
    alert("無法啟動攝影機，請檢查權限！");
    return;
  }

  const camera=new Camera(video,{
    onFrame:async()=>{
        if(isProcessing) return; 
        isProcessing = true;
        try {
            await hands.send({image:video});
        } catch (error) {
            console.log("忽略錯誤:", error);
        } finally {
            isProcessing = false;
        }
    },
    width:640,height:480
  });
  camera.start();

  for(let i=0;i<3;i++)spawnHole();
  spawnCreature(); 
  setInterval(spawnCreature, 3500); 
  setInterval(spawnHole,7000);

  startTimer();
  draw();
}

window.onload = startCamera;
</script>
</body>
</html>